/*
 *                    GNU LESSER GENERAL PUBLIC LICENSE
 *                        Version 3, 29 June 2007
 * 
 *  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 *  Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 * 
 * 
 *   This version of the GNU Lesser General Public License incorporates
 * the terms and conditions of version 3 of the GNU General Public
 * License, supplemented by the additional permissions listed below.
 * 
 *   0. Additional Definitions.
 * 
 *   As used herein, "this License" refers to version 3 of the GNU Lesser
 * General Public License, and the "GNU GPL" refers to version 3 of the GNU
 * General Public License.
 * 
 *   "The Library" refers to a covered work governed by this License,
 * other than an Application or a Combined Work as defined below.
 * 
 *   An "Application" is any work that makes use of an interface provided
 * by the Library, but which is not otherwise based on the Library.
 * Defining a subclass of a class defined by the Library is deemed a mode
 * of using an interface provided by the Library.
 * 
 *   A "Combined Work" is a work produced by combining or linking an
 * Application with the Library.  The particular version of the Library
 * with which the Combined Work was made is also called the "Linked
 * Version".
 * 
 *   The "Minimal Corresponding Source" for a Combined Work means the
 * Corresponding Source for the Combined Work, excluding any source code
 * for portions of the Combined Work that, considered in isolation, are
 * based on the Application, and not on the Linked Version.
 * 
 *   The "Corresponding Application Code" for a Combined Work means the
 * object code and/or source code for the Application, including any data
 * and utility programs needed for reproducing the Combined Work from the
 * Application, but excluding the System Libraries of the Combined Work.
 * 
 *   1. Exception to Section 3 of the GNU GPL.
 * 
 *   You may convey a covered work under sections 3 and 4 of this License
 * without being bound by section 3 of the GNU GPL.
 * 
 *   2. Conveying Modified Versions.
 * 
 *   If you modify a copy of the Library, and, in your modifications, a
 * facility refers to a function or data to be supplied by an Application
 * that uses the facility (other than as an argument passed when the
 * facility is invoked), then you may convey a copy of the modified
 * version:
 * 
 *    a) under this License, provided that you make a good faith effort to
 *    ensure that, in the event an Application does not supply the
 *    function or data, the facility still operates, and performs
 *    whatever part of its purpose remains meaningful, or
 * 
 *    b) under the GNU GPL, with none of the additional permissions of
 *    this License applicable to that copy.
 * 
 *   3. Object Code Incorporating Material from Library Header Files.
 * 
 *   The object code form of an Application may incorporate material from
 * a header file that is part of the Library.  You may convey such object
 * code under terms of your choice, provided that, if the incorporated
 * material is not limited to numerical parameters, data structure
 * layouts and accessors, or small macros, inline functions and templates
 * (ten or fewer lines in length), you do both of the following:
 * 
 *    a) Give prominent notice with each copy of the object code that the
 *    Library is used in it and that the Library and its use are
 *    covered by this License.
 * 
 *    b) Accompany the object code with a copy of the GNU GPL and this license
 *    document.
 * 
 *   4. Combined Works.
 *   You may convey a Combined Work under terms of your choice that,
 * taken together, effectively do not restrict modification of the
 * portions of the Library contained in the Combined Work and reverse
 * engineering for debugging such modifications, if you also do each of
 * the following:
 * 
 *    a) Give prominent notice with each copy of the Combined Work that
 *    the Library is used in it and that the Library and its use are
 *    covered by this License.
 * 
 *    b) Accompany the Combined Work with a copy of the GNU GPL and this license
 *    document.
 * 
 *    c) For a Combined Work that displays copyright notices during
 *    execution, include the copyright notice for the Library among
 *    these notices, as well as a reference directing the user to the
 *    copies of the GNU GPL and this license document.
 * 
 *    d) Do one of the following:
 * 
 *        0) Convey the Minimal Corresponding Source under the terms of this
 *        License, and the Corresponding Application Code in a form
 *        suitable for, and under terms that permit, the user to
 *        recombine or relink the Application with a modified version of
 *        the Linked Version to produce a modified Combined Work, in the
 *        manner specified by section 6 of the GNU GPL for conveying
 *        Corresponding Source.
 * 
 *        1) Use a suitable shared library mechanism for linking with the
 *        Library.  A suitable mechanism is one that (a) uses at run time
 *        a copy of the Library already present on the user's computer
 *        system, and (b) will operate properly with a modified version
 *        of the Library that is interface-compatible with the Linked
 *        Version.
 * 
 *    e) Provide Installation Information, but only if you would otherwise
 *    be required to provide such information under section 6 of the
 *    GNU GPL, and only to the extent that such information is
 *    necessary to install and execute a modified version of the
 *    Combined Work produced by recombining or relinking the
 *    Application with a modified version of the Linked Version. (If
 *    you use option 4d0, the Installation Information must accompany
 *    the Minimal Corresponding Source and Corresponding Application
 *    Code. If you use option 4d1, you must provide the Installation
 *    Information in the manner specified by section 6 of the GNU GPL
 *    for conveying Corresponding Source.)
 * 
 *   5. Combined Libraries.
 * 
 *   You may place library facilities that are a work based on the
 * Library side by side in a single library together with other library
 * facilities that are not Applications and are not covered by this
 * License, and convey such a combined library under terms of your
 * choice, if you do both of the following:
 * 
 *    a) Accompany the combined library with a copy of the same work based
 *    on the Library, uncombined with any other library facilities,
 *    conveyed under the terms of this License.
 * 
 *    b) Give prominent notice with the combined library that part of it
 *    is a work based on the Library, and explaining where to find the
 *    accompanying uncombined form of the same work.
 * 
 *   6. Revised Versions of the GNU Lesser General Public License.
 * 
 *   The Free Software Foundation may publish revised and/or new versions
 * of the GNU Lesser General Public License from time to time. Such new
 * versions will be similar in spirit to the present version, but may
 * differ in detail to address new problems or concerns.

 *   Each version is given a distinguishing version number. If the
 * Library as you received it specifies that a certain numbered version
 * of the GNU Lesser General Public License "or any later version"
 * applies to it, you have the option of following the terms and
 * conditions either of that published version or of any later version
 * published by the Free Software Foundation. If the Library as you
 * received it does not specify a version number of the GNU Lesser
 * General Public License, you may choose any version of the GNU Lesser
 * General Public License ever published by the Free Software Foundation.
 * 
 *   If the Library as you received it specifies that a proxy can decide
 * whether future versions of the GNU Lesser General Public License shall
 * apply, that proxy's public statement of acceptance of any version is
 * permanent authorization for you to choose that version for the
 * Library.
 */

package com.sadofftext.Symbolic;

import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.Locale;

/**
 * The class variable. This is used to represent a variable in a CAS.
 * As such 'x' can just be 'x' and not the typical: `int x = 2`.
 * 
 * Examples:
 * <ul>
 *  <li> 3x<sup>2</sup> &mdash; {@code new Variable(3, "x", 2);} </li>
 *  <li> 3x &mdash; {@code new Variable(3, "x");} </li>
 *  <li> x<sup>2</sup> &mdash; {@code new Variable("x", 2);} </li>
 *  <li> x &mdash; {@code new Variable("x");} </li>
 * </ul>
 * 
 * @author Eli David Sadoff
 * @since 1.0
 * @version 1.0
 *
 */
public class Variable implements Operations<Variable>{
  /** This holds the coefficient of the variable */
  private Numeric coefficient;
  /** This holds the name of the variable */
  private String name;
  /** This holds the exponent */
  private Numeric exponent;
  
  /**
   * This is the convenience constructor for the Variable.
   * This is to be used for a variable with a coefficient and exponent.
   * 
   * @param coefficient the coefficient to set
   * @param name the name to set 
   * @param exponent the exponent to set
   */
  public Variable(Numeric coefficient, String name, Numeric exponent){
    this.coefficient  = coefficient;
    this.name = name;
    this.exponent = exponent;
  }
  
  /**
   * This is the convenience constructor for the Variable.
   * This is to be used for a variable with a coefficient and exponent.
   * 
   * @param coefficient the coefficient to set
   * @param name the name to set 
   * @param exponent the exponent to set
   */
  public Variable(int coefficient, String name, int exponent){
    this.coefficient  = new IntegerType(coefficient);
    this.name = name;
    this.exponent = new IntegerType(exponent);
  }
  
  /**
   * This is a constructor for a variable with a coefficient but no exponent.
   * 
   * @param coefficient the coefficient to set
   * @param name the name to set 
   */
  public Variable(Numeric coefficient, String name){
    this.coefficient = coefficient;
    this.name = name;
    this.exponent = Numeric.ONE;
  }
  
  /**
   * This is a constructor for a variable with a coefficient but no exponent.
   * 
   * @param coefficient the coefficient to set
   * @param name the name to set 
   */
  public Variable(int coefficient, String name){
    this.coefficient = new IntegerType(coefficient);
    this.name = name;
    this.exponent = Numeric.ONE;
  }
  
  /**
   * This is a constructor for a variable with an exponent but no coefficient
   * 
   * @param name the name to set
   * @param exponent the exponent to set
   */
  public Variable(String name, Numeric exponent){
    this.coefficient = Numeric.ONE;
    this.name = name;
    this.exponent = exponent;
  }
  
  /**
   * This is a constructor for a variable with an exponent but no coefficient
   * 
   * @param name the name to set
   * @param exponent the exponent to set
   */
  public Variable(String name, int exponent){
    this.coefficient = Numeric.ONE;
    this.name = name;
    this.exponent = new IntegerType(exponent);
  }
  
  /**
   * This is the constructor for a variable with no exponent or coefficient.
   * 
   * @param name the name to set
   */
  public Variable(String name){
    this.coefficient = Numeric.ONE;
    this.name = name;
    this.exponent = Numeric.ONE;
  }
  
  /**
   * Gets {@code coefficient}.
   * @return the coefficient
   */
  public Numeric getCoefficient() {
    return coefficient;
  }

  /**
   * Sets {@code coefficient}.
   * @param coefficient the coefficient to set
   */
  public void setCoefficient(Numeric coefficient) {
    this.coefficient = coefficient;
  }

  /**
   * Gets {@code name}.
   * @return the name
   */
  public String getName() {
    return name;
  }

  /**
   * Sets {@code name}.
   * @param name the name to set
   */
  public void setName(String name) {
    this.name = name;
  }

  /**
   * Gets {@code exponent}.
   * @return the exponent
   */
  public Numeric getExponent() {
    return exponent;
  }

  /**
   * Sets {@code exponent}.
   * @param exponent the exponent to set
   */
  public void setExponent(Numeric exponent) {
    this.exponent = exponent;
  }

  /**
   * This method gets the <code>TeX</code> formatting of a variable.
   * @return a TeX formatted variable
   */
  public String getTeX(){
    if(getExponent().equals(1) && getCoefficient().equals(1)){
      return getName();
    } else if(getExponent().equals(1)){
      return getCoefficient().toString() + getName();
    } else if(getCoefficient().equals(1)){
      return getName() + "^{" + getExponent().toString() + "}";
    } else{
      return getCoefficient() + getName() + "^{" + getExponent().toString() + "}";
    }
  }
  
  /** 
   * @param o added
   * @return sum
   * @see com.sadofftext.Symbolic.Operations#add(java.lang.Object)
   */
  @Override
  public Variable add(Variable o) {
    // TODO Auto-generated method stub
    return null;
  }

  /** 
   * @param o subtractor
   * @return difference
   * @see com.sadofftext.Symbolic.Operations#subtract(java.lang.Object)
   */
  @Override
  public Variable subtract(Variable o) {
    // TODO Auto-generated method stub
    return null;
  }

  /** 
   * @param o multiplicand 
   * @return product
   * @see com.sadofftext.Symbolic.Operations#multiply(java.lang.Object)
   */
  @Override
  public Variable multiply(Variable o) {
    // TODO Auto-generated method stub
    return null;
  }

  /** 
   * @param o divisor
   * @return quotient
   * @see com.sadofftext.Symbolic.Operations#divide(java.lang.Object)
   */
  @Override
  public Variable divide(Variable o) {
    // TODO Auto-generated method stub
    return null;
  }

  /** 
   * Returns a hash code for this variable.
   * 
   * @return a hash code value for this object.
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((coefficient == null) ? 0 : coefficient.hashCode());
    result = prime * result + ((exponent == null) ? 0 : exponent.hashCode());
    result = prime * result + ((name == null) ? 0 : getName().hashCode());
    return result;
  }

  /** 
   * Checks equality against another object
   * 
   * @param obj the object to check equality against
   * @return true if the objects are the same false otherwise
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (!(obj instanceof Variable))
      return false;
    Variable other = (Variable) obj;
    if (coefficient == null) {
      if (other.coefficient != null)
        return false;
    } else if (!coefficient.equals(other.coefficient))
      return false;
    if (exponent == null) {
      if (other.exponent != null)
        return false;
    } else if (!exponent.equals(other.exponent))
      return false;
    if (name == null) {
      if (other.name != null)
        return false;
    } else if (!getName().equals(other.name))
      return false;
    return true;
  }

  /**
   * Returns the length of the string
   * 
   * @return the length of the string
   * @see java.lang.String#length()
   */
  public int length() {
    return getName().length();
  }

  /**
   * Returns if the string is empty
   * 
   * @return true if the string is empty
   * @see java.lang.String#isEmpty()
   */
  public boolean isEmpty() {
    return getName().isEmpty();
  }

  /**
   * Returns the char at the specified index.
   * 
   * @param index the index to the char value
   * @return the char at the specified index
   * @see java.lang.String#charAt(int)
   */
  public char charAt(int index) {
    return getName().charAt(index);
  }

  /**
   * Returns the character (Unicode code point) at the specified index. The index refers to char values (Unicode code units) and ranges from 0 to length()- 1.
   * 
   * @param index the index to the char values
   * @return the code point value of the character at the index
   * @see java.lang.String#codePointAt(int)
   */
  public int codePointAt(int index) {
    return getName().codePointAt(index);
  }

  /**
   * Returns the character (Unicode code point) before the specified index. The index refers to char values (Unicode code units) and ranges from 1 to length.
   * 
   * @param index the index following the code point that should be returned
   * @return the Unicode code point value before the given index.
   * @see java.lang.String#codePointBefore(int)
   */
  public int codePointBefore(int index) {
    return getName().codePointBefore(index);
  }

  /**
   * Returns the number of Unicode code points in the specified text range of this String. The text range begins at the specified beginIndex and extends to the char at index endIndex - 1. Thus the length (in chars) of the text range is endIndex-beginIndex. Unpaired surrogates within the text range count as one code point each.
   * 
   * @param beginIndex the index to the first char of the text range
   * @param endIndex the index after the last char of the text range
   * @return the number of Unicode code points in the specified text range
   * @see java.lang.String#codePointCount(int, int)
   */
  public int codePointCount(int beginIndex, int endIndex) {
    return getName().codePointCount(beginIndex, endIndex);
  }

  /**
   * Returns the index within this String that is offset from the given index by codePointOffset code points. Unpaired surrogates within the text range given by index and codePointOffset count as one code point each.
   * 
   * @param index the index to be offset
   * @param codePointOffset the offset in code points
   * @return the index within this String
   * @see java.lang.String#offsetByCodePoints(int, int)
   */
  public int offsetByCodePoints(int index, int codePointOffset) {
    return getName().offsetByCodePoints(index, codePointOffset);
  }

  /**
   * Copies characters from this string into the destination character array.
   * 
   * @param srcBegin Index of the first character in the string to copy
   * @param srcEnd Index of the last character in the string to copy
   * @param dst The destination array
   * @param dstBegin The start offset in the destination array
   * @throws IndexOutOfBoundsException if:
   * <ul>
   *    <li><code>srcBegin</code> is negative</li>
   *    <li><code>srcBegin</code> is greater than <code>srcEnd</code></li>
   *    <li><code>srcEnd</code> is greater than the length of this String</li>
   *    <li><code>dstBegin</code> is negative</li>
   *    <li><code>dstBegin+(srcEnd-srcBegin)</code> is larger than dst.length</li>
   * </ul>
   * @see java.lang.String#getChars(int, int, char[], int)
   */
  public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {
    getName().getChars(srcBegin, srcEnd, dst, dstBegin);
  }

  /**
   * This method does not properly convert characters into bytes. As of JDK 1.1, the preferred way to do this is via the getBytes() method, which uses the platform's default charset.
   * 
   * @param srcBegin Index of the first character in the string to copy
   * @param srcEnd Index of the last character in the string to copy
   * @param dst The destination array
   * @param dstBegin The start offset in the destination array
   * @deprecated
   * @throws IndexOutOfBoundsException if:
   * <ul>
   *    <li><code>srcBegin</code> is negative</li>
   *    <li><code>srcBegin</code> is greater than <code>srcEnd</code></li>
   *    <li><code>srcEnd</code> is greater than the length of this String</li>
   *    <li><code>dstBegin</code> is negative</li>
   *    <li><code>dstBegin+(srcEnd-srcBegin)</code> is larger than dst.length</li>
   * </ul>
   * @see java.lang.String#getBytes(int, int, byte[], int)
   */
  @Deprecated
  public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) throws IndexOutOfBoundsException {
    getName().getBytes(srcBegin, srcEnd, dst, dstBegin);
  }

  /**
   * Encodes this String into a sequence of bytes using the specified charset, storing the result into a new byte array.
   * 
   * @param charsetName the charset to use
   * @return the string encoded into a byte array
   * @throws UnsupportedEncodingException thrown if the encoding specified is unsupported
   * @see java.lang.String#getBytes(java.lang.String)
   */
  public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {
    return getName().getBytes(charsetName);
  }

  /**
   * Encodes this String into a sequence of bytes using the specified charset, storing the result into a new byte array.
   * 
   * @param charset the charset to use
   * @return the string encoded into a byte array
   * @see java.lang.String#getBytes(java.nio.charset.Charset)
   */
  public byte[] getBytes(Charset charset) {
    return getName().getBytes(charset);
  }

  /**
   * Encodes this String into a sequence of bytes using the platform's default charset, storing the result into a new byte array.
   * 
   * @return the string encoded into a byte array 
   * @see java.lang.String#getBytes()
   */
  public byte[] getBytes() {
    return getName().getBytes();
  }

  /**
   * Checks equality against a StringBuffer. Equivalent to checking {@code equals(sb.toString)}.
   * 
   * @param sb the StringBuffer to check
   * @return true if they are equal in content.
   * @see java.lang.String#contentEquals(java.lang.StringBuffer)
   */
  public boolean contentEquals(StringBuffer sb) {
    return getName().contentEquals(sb);
  }

  /**
   * Checks equality against a CharSequence
   * 
   * @param cs the CharSequqence to check equality against
   * @return true if the CharSequence and string have the same contents.
   * @see java.lang.String#contentEquals(java.lang.CharSequence)
   */
  public boolean contentEquals(CharSequence cs) {
    return getName().contentEquals(cs);
  }

  /**
   * Checks equality while ignoring case
   * 
   * @param anotherString the string to check equality against
   * @return true if the two strings are equal ignoring case.
   * @see java.lang.String#equalsIgnoreCase(java.lang.String)
   */
  public boolean equalsIgnoreCase(String anotherString) {
    return getName().equalsIgnoreCase(anotherString);
  }

  /**
   * Compares two strings lexicographically. The comparison is based on the Unicode value of each character in the strings. The character sequence represented by this String object is compared lexicographically to the character sequence represented by the argument string. The result is a negative integer if this String object lexicographically precedes the argument string. The result is a positive integer if this String object lexicographically follows the argument string. The result is zero if the strings are equal; compareTo returns 0 exactly when the equals(Object) method would return true.
   * 
   * @param anotherString the string to compare to
   * @return a negative integer, zero, or a positive integer as the specified String is greater than, equal to, or less than this String.
   * @see java.lang.String#compareTo(java.lang.String)
   */
  public int compareTo(String anotherString) {
    return getName().compareTo(anotherString);
  }

  /**
   * Compares two strings lexicographically, ignoring case differences. This method returns an integer whose sign is that of calling compareTo with normalized versions of the strings where case differences have been eliminated by calling Character.toLowerCase(Character.toUpperCase(character)) on each character.
   *
   * @param str the string to compare
   * @return  a negative integer, zero, or a positive integer as the specified String is greater than, equal to, or less than this String, ignoring case considerations.
   * @see java.lang.String#compareToIgnoreCase(java.lang.String)
   */
  public int compareToIgnoreCase(String str) {
    return getName().compareToIgnoreCase(str);
  }

  /**
   * Tests if two string regions are equal.
   * A substring of this String object is compared to a substring of the argument other. The result is true if these substrings represent identical character sequences. The substring of this String object to be compared begins at index toffset and has length len. The substring of other to be compared begins at index ooffset and has length len. The result is false if and only if at least one of the following is true:
   * <ul>
   *   <li> {@code toffset} is negative.</li>
   *   <li> {@code ooffset} is negative.</li>
   *   <li> {@code toffset+len} is greater than the length of this String object. </li>
   *   <li> {@code ooffset+len} is greater than the length of the other argument. </li>
   *   <li> There is some nonnegative integer {@code k} less than {@code len} such that: {@code this.charAt(toffset + k) != other.charAt(ooffset + k)} </li>
   * @param toffset the starting offset of the subregion in this string.
   * @param other the string argument.
   * @param ooffset the starting offset of the subregion in the string argument.
   * @param len the number of strings to compare
   * @return true if the region matches
   * @see java.lang.String#regionMatches(int, java.lang.String, int, int)
   */
  public boolean regionMatches(int toffset, String other, int ooffset, int len) {
    return getName().regionMatches(toffset, other, ooffset, len);
  }

  /**
   * Tests if two string regions are equal.
   * A substring of this String object is compared to a substring of the argument other. The result is true if these substrings represent identical character sequences. The substring of this String object to be compared begins at index toffset and has length len. The substring of other to be compared begins at index ooffset and has length len. The result is false if and only if at least one of the following is true:
   * <ul>
   *   <li> {@code toffset} is negative.</li>
   *   <li> {@code ooffset} is negative.</li>
   *   <li> {@code toffset+len} is greater than the length of this String object. </li>
   *   <li> {@code ooffset+len} is greater than the length of the other argument. </li>
   *   <li> {@code ignoreCase} is false and there is some nonnegative integer {@code k} less than {@code len} such that: {@code this.charAt(toffset + k) != other.charAt(ooffset + k)} </li>
   *   <li> ignoreCase is true and there is some nonnegative integer k less than len such that:
   *  {@code Character.toLowerCase(this.charAt(toffset+k)) !=
   *  Character.toLowerCase(other.charAt(ooffset+k))}
   *
   * and:
   * {@code Character.toUpperCase(this.charAt(toffset+k)) !=
   *     Character.toUpperCase(other.charAt(ooffset+k))}</li>
   * </ul>
   * @param ignoreCase if true, ignore case when comparing characters.
   * @param toffset the starting offset of the subregion in this string.
   * @param other the string argument.
   * @param ooffset the starting offset of the subregion in the string argument.
   * @param len the number of strings to compare
   * @return true if the region matches
   * @see java.lang.String#regionMatches(boolean, int, java.lang.String, int, int)
   */
  public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset,
      int len) {
    return getName().regionMatches(ignoreCase, toffset, other, ooffset, len);
  }

  /**
   * Checks if the string starts with the specified prefix and offset
   * 
   * @param prefix the prefix to check
   * @param toffset the index to start at
   * @return if the string starts with the prefix at that offset
   * @see java.lang.String#startsWith(java.lang.String, int)
   */
  public boolean startsWith(String prefix, int toffset) {
    return getName().startsWith(prefix, toffset);
  }

  /**
   * Checks if the string starts with the specified prefix
   * 
   * @param prefix the prefix to check
   * @return if the string starts with that prefix
   * @see java.lang.String#startsWith(java.lang.String)
   */
  public boolean startsWith(String prefix) {
    return getName().startsWith(prefix);
  }

  /**
   * Checks if the string ends with the provided suffix
   * 
   * @param suffix the suffix to check
   * @return if the string ends with the suffix
   * @see java.lang.String#endsWith(java.lang.String)
   */
  public boolean endsWith(String suffix) {
    return getName().endsWith(suffix);
  }

  /**
   * Returns the index within this string of the first occurrence of the specified char.
   * 
   * @param ch the char to search for
   * @return the index of the first occurrence of the specified char or -1 if there is no such occurrence.
   * @see java.lang.String#indexOf(int)
   */
  public int indexOf(int ch) {
    return getName().indexOf(ch);
  }

  /**
   * Returns the index within this string of the first occurrence of the specified char, starting at the specified index searching forward.
   * 
   * @param ch the char to search for
   * @param fromIndex the index to start from
   * @return the index of the first occurrence of the specified char, searching forward from the specified index, or -1 if there is no such occurrence.
   * @see java.lang.String#indexOf(int, int)
   */
  public int indexOf(int ch, int fromIndex) {
    return getName().indexOf(ch, fromIndex);
  }

  /**
   * Returns the index within this string of the last occurrence of the specified char.
   * 
   * @param ch the char to search for
   * @return the index of the last occurrence of the specified char or -1 if there is no such occurrence.
   * @see java.lang.String#lastIndexOf(int)
   */
  public int lastIndexOf(int ch) {
    return getName().lastIndexOf(ch);
  }

  /**
   * Returns the index within this string of the last occurrence of the specified char, searching backward starting at the specified index.
   * 
   * @param ch the char to search for
   * @param fromIndex the index to start from
   * @return the index of the last occurrence of the specified char, searching backward from the specified index, or -1 if there is no such occurrence.
   * @see java.lang.String#lastIndexOf(int, int)
   */
  public int lastIndexOf(int ch, int fromIndex) {
    return getName().lastIndexOf(ch, fromIndex);
  }

  /**
   * Returns the index within this string of the first occurrence of the specified substring.
   * 
   * @param str the substring to search for
   * @return the index of the first occurrence of the specified substring or -1 if there is no such occurence.
   * @see java.lang.String#indexOf(java.lang.String)
   */
  public int indexOf(String str) {
    return getName().indexOf(str);
  }

  /**
   * Returns the index within this string of the first occurrence of the specified substring, starting at the specified index searching forward.
   * 
   * @param str the substring to search for
   * @param fromIndex the index to start from
   * @return the index of the first occurrence of the specified substring, searching forward from the specified index, or -1 if there is no such occurrence.
   * @see java.lang.String#indexOf(java.lang.String, int)
   */
  public int indexOf(String str, int fromIndex) {
    return getName().indexOf(str, fromIndex);
  }

  /**
   * Returns the index within this string of the last occurrence of the specified substring.
   * 
   * @param str the substring to search for
   * @return the index of the last occurrence of the specified substring or -1 if there is no such occurrence.
   * @see java.lang.String#lastIndexOf(java.lang.String)
   */
  public int lastIndexOf(String str) {
    return getName().lastIndexOf(str);
  }

  /**
   * Returns the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index.
   * 
   * @param str the substring to search for
   * @param fromIndex the index to start from
   * @return the index of the last occurrence of the specified substring, searching backward from the specified index, or -1 if there is no such occurrence.
   * @see java.lang.String#lastIndexOf(java.lang.String, int)
   */
  public int lastIndexOf(String str, int fromIndex) {
    return getName().lastIndexOf(str, fromIndex);
  }

  /**
   * Gets a substring from a string.
   * 
   * @param beginIndex the index to begin from
   * @return a String from beginIndex to the end of the String.
   * @see java.lang.String#substring(int)
   */
  public String substring(int beginIndex) {
    return getName().substring(beginIndex);
  }

  /**
   * Gets a substring from a string.
   * 
   * @param beginIndex the index to start at
   * @param endIndex the index to end at
   * @return a String from beginIndex to endIndex
   * @see java.lang.String#substring(int, int)
   */
  public String substring(int beginIndex, int endIndex) {
    return getName().substring(beginIndex, endIndex);
  }

  /**
   * Gets a CharSequence from a string.
   * 
   * @param beginIndex the index to start at
   * @param endIndex the index to end at
   * @return a CharSequence from beginIndex to endIndex
   * @see java.lang.String#subSequence(int, int)
   */
  public CharSequence subSequence(int beginIndex, int endIndex) {
    return getName().subSequence(beginIndex, endIndex);
  }

  /**
   * Concatenates two strings
   * 
   * @param str the string to concatenate
   * @return a concatenated string
   * @see java.lang.String#concat(java.lang.String)
   */
  public String concat(String str) {
    return getName().concat(str);
  }

  /**
   * Replaces one char with another char
   * 
   * @param oldChar the char to replace
   * @param newChar the replacement for the char
   * @return a string where the oldchar is replaced by the new char
   * @see java.lang.String#replace(char, char)
   */
  public String replace(char oldChar, char newChar) {
    return getName().replace(oldChar, newChar);
  }

  /**
   * Checks if the variable matches a regular expression.
   * 
   * @param regex the regular expression to check if the string matches
   * @return if the string matches the pattern
   * @see java.lang.String#matches(java.lang.String)
   */
  public boolean matches(String regex) {
    return getName().matches(regex);
  }

  /**
   * Checks if the variable contains a char sequence
   * 
   * @param s the sequence to check
   * @return if the variable name contains the sequence
   * @see java.lang.String#contains(java.lang.CharSequence)
   */
  public boolean contains(CharSequence s) {
    return getName().contains(s);
  }

  /**
   * Replace the first occurrence of a pattern with a string.
   * 
   * @param regex the regular expression to replace 
   * @param replacement the replacement
   * @return a string with the first matching pattern replaced
   * @see java.lang.String#replaceFirst(java.lang.String, java.lang.String)
   */
  public String replaceFirst(String regex, String replacement) {
    return getName().replaceFirst(regex, replacement);
  }

  /**
   * Replaces all patterns with a string.
   * 
   * @param regex the regular expression to replace
   * @param replacement the replacement
   * @return a string with all of the matching patterns replaced
   * @see java.lang.String#replaceAll(java.lang.String, java.lang.String)
   */
  public String replaceAll(String regex, String replacement) {
    return getName().replaceAll(regex, replacement);
  }

  /**
   * Replaces a CharSequence with another CharSequence
   * 
   * @param target the sequence of characters to replace
   * @param replacement the replacement
   * @return a transformed char
   * @see java.lang.String#replace(java.lang.CharSequence, java.lang.CharSequence)
   */
  public String replace(CharSequence target, CharSequence replacement) {
    return getName().replace(target, replacement);
  }

  /**
   * Splits the string at the provided pattern a certain number of times.
   * 
   * @param regex the regex to split the string
   * @param limit the number of times the string is to be split
   * @return a split string
   * @see java.lang.String#split(java.lang.String, int)
   * @see #split(String)
   */
  public String[] split(String regex, int limit) {
    return getName().split(regex, limit);
  }

  /**
   * Splits the string at the provided pattern
   * 
   * @param regex the regular expression on which to split the string
   * @return a string split by the provided regex
   * @see java.lang.String#split(java.lang.String)
   */
  public String[] split(String regex) {
    return getName().split(regex);
  }

  /**
   * Turns the variable name to a locale specific lower case
   * 
   * @param locale the locale of the user
   * @return the string into a locale based lower case
   * @see java.lang.String#toLowerCase(java.util.Locale)
   * @see #toLowerCase()
   */
  public String toLowerCase(Locale locale) {
    return getName().toLowerCase(locale);
  }

  /**
   * Turns the variable name to lower case
   * 
   * @return the variable name in lower case
   * @see java.lang.String#toLowerCase()
   */
  public String toLowerCase() {
    return getName().toLowerCase();
  }

  /**
   * Turns the variable name into a locale specific upper case
   * 
   * @param locale the locale of the user
   * @return turns the string into a locale based upper case
   * @see java.lang.String#toUpperCase(java.util.Locale)
   * @see #toUpperCase()
   */
  public String toUpperCase(Locale locale) {
    return getName().toUpperCase(locale);
  }

  /**
   * The variable name in all upper case
   * 
   * @return the variable name in all upper case
   * @see java.lang.String#toUpperCase()
   */
  public String toUpperCase() {
    return getName().toUpperCase();
  }

  /**
   * Returns a string whose value is this string, with any leading and trailing whitespace removed.
   * 
   * @return The variable name with leading and trailing whitespace removed
   * @see java.lang.String#trim()
   */
  public String trim() {
    return getName().trim();
  }

  /**
   * Turns name into a charArray
   * 
   * @return a char array of the string name
   * @see java.lang.String#toCharArray()
   */
  public char[] toCharArray() {
    return getName().toCharArray();
  }

  /**
   * Returns a canonical representation for the string object.
   * 
   * @return a string identical in characters to the string in Name, but from a unique pool
   * @see java.lang.String#intern()
   */
  public String intern() {
    return getName().intern();
  }
}
