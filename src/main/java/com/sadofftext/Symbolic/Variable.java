/*
 *                    GNU LESSER GENERAL PUBLIC LICENSE
 *                        Version 3, 29 June 2007
 * 
 *  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 *  Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 * 
 * 
 *   This version of the GNU Lesser General Public License incorporates
 * the terms and conditions of version 3 of the GNU General Public
 * License, supplemented by the additional permissions listed below.
 * 
 *   0. Additional Definitions.
 * 
 *   As used herein, "this License" refers to version 3 of the GNU Lesser
 * General Public License, and the "GNU GPL" refers to version 3 of the GNU
 * General Public License.
 * 
 *   "The Library" refers to a covered work governed by this License,
 * other than an Application or a Combined Work as defined below.
 * 
 *   An "Application" is any work that makes use of an interface provided
 * by the Library, but which is not otherwise based on the Library.
 * Defining a subclass of a class defined by the Library is deemed a mode
 * of using an interface provided by the Library.
 * 
 *   A "Combined Work" is a work produced by combining or linking an
 * Application with the Library.  The particular version of the Library
 * with which the Combined Work was made is also called the "Linked
 * Version".
 * 
 *   The "Minimal Corresponding Source" for a Combined Work means the
 * Corresponding Source for the Combined Work, excluding any source code
 * for portions of the Combined Work that, considered in isolation, are
 * based on the Application, and not on the Linked Version.
 * 
 *   The "Corresponding Application Code" for a Combined Work means the
 * object code and/or source code for the Application, including any data
 * and utility programs needed for reproducing the Combined Work from the
 * Application, but excluding the System Libraries of the Combined Work.
 * 
 *   1. Exception to Section 3 of the GNU GPL.
 * 
 *   You may convey a covered work under sections 3 and 4 of this License
 * without being bound by section 3 of the GNU GPL.
 * 
 *   2. Conveying Modified Versions.
 * 
 *   If you modify a copy of the Library, and, in your modifications, a
 * facility refers to a function or data to be supplied by an Application
 * that uses the facility (other than as an argument passed when the
 * facility is invoked), then you may convey a copy of the modified
 * version:
 * 
 *    a) under this License, provided that you make a good faith effort to
 *    ensure that, in the event an Application does not supply the
 *    function or data, the facility still operates, and performs
 *    whatever part of its purpose remains meaningful, or
 * 
 *    b) under the GNU GPL, with none of the additional permissions of
 *    this License applicable to that copy.
 * 
 *   3. Object Code Incorporating Material from Library Header Files.
 * 
 *   The object code form of an Application may incorporate material from
 * a header file that is part of the Library.  You may convey such object
 * code under terms of your choice, provided that, if the incorporated
 * material is not limited to numerical parameters, data structure
 * layouts and accessors, or small macros, inline functions and templates
 * (ten or fewer lines in length), you do both of the following:
 * 
 *    a) Give prominent notice with each copy of the object code that the
 *    Library is used in it and that the Library and its use are
 *    covered by this License.
 * 
 *    b) Accompany the object code with a copy of the GNU GPL and this license
 *    document.
 * 
 *   4. Combined Works.
 *   You may convey a Combined Work under terms of your choice that,
 * taken together, effectively do not restrict modification of the
 * portions of the Library contained in the Combined Work and reverse
 * engineering for debugging such modifications, if you also do each of
 * the following:
 * 
 *    a) Give prominent notice with each copy of the Combined Work that
 *    the Library is used in it and that the Library and its use are
 *    covered by this License.
 * 
 *    b) Accompany the Combined Work with a copy of the GNU GPL and this license
 *    document.
 * 
 *    c) For a Combined Work that displays copyright notices during
 *    execution, include the copyright notice for the Library among
 *    these notices, as well as a reference directing the user to the
 *    copies of the GNU GPL and this license document.
 * 
 *    d) Do one of the following:
 * 
 *        0) Convey the Minimal Corresponding Source under the terms of this
 *        License, and the Corresponding Application Code in a form
 *        suitable for, and under terms that permit, the user to
 *        recombine or relink the Application with a modified version of
 *        the Linked Version to produce a modified Combined Work, in the
 *        manner specified by section 6 of the GNU GPL for conveying
 *        Corresponding Source.
 * 
 *        1) Use a suitable shared library mechanism for linking with the
 *        Library.  A suitable mechanism is one that (a) uses at run time
 *        a copy of the Library already present on the user's computer
 *        system, and (b) will operate properly with a modified version
 *        of the Library that is interface-compatible with the Linked
 *        Version.
 * 
 *    e) Provide Installation Information, but only if you would otherwise
 *    be required to provide such information under section 6 of the
 *    GNU GPL, and only to the extent that such information is
 *    necessary to install and execute a modified version of the
 *    Combined Work produced by recombining or relinking the
 *    Application with a modified version of the Linked Version. (If
 *    you use option 4d0, the Installation Information must accompany
 *    the Minimal Corresponding Source and Corresponding Application
 *    Code. If you use option 4d1, you must provide the Installation
 *    Information in the manner specified by section 6 of the GNU GPL
 *    for conveying Corresponding Source.)
 * 
 *   5. Combined Libraries.
 * 
 *   You may place library facilities that are a work based on the
 * Library side by side in a single library together with other library
 * facilities that are not Applications and are not covered by this
 * License, and convey such a combined library under terms of your
 * choice, if you do both of the following:
 * 
 *    a) Accompany the combined library with a copy of the same work based
 *    on the Library, uncombined with any other library facilities,
 *    conveyed under the terms of this License.
 * 
 *    b) Give prominent notice with the combined library that part of it
 *    is a work based on the Library, and explaining where to find the
 *    accompanying uncombined form of the same work.
 * 
 *   6. Revised Versions of the GNU Lesser General Public License.
 * 
 *   The Free Software Foundation may publish revised and/or new versions
 * of the GNU Lesser General Public License from time to time. Such new
 * versions will be similar in spirit to the present version, but may
 * differ in detail to address new problems or concerns.

 *   Each version is given a distinguishing version number. If the
 * Library as you received it specifies that a certain numbered version
 * of the GNU Lesser General Public License "or any later version"
 * applies to it, you have the option of following the terms and
 * conditions either of that published version or of any later version
 * published by the Free Software Foundation. If the Library as you
 * received it does not specify a version number of the GNU Lesser
 * General Public License, you may choose any version of the GNU Lesser
 * General Public License ever published by the Free Software Foundation.
 * 
 *   If the Library as you received it specifies that a proxy can decide
 * whether future versions of the GNU Lesser General Public License shall
 * apply, that proxy's public statement of acceptance of any version is
 * permanent authorization for you to choose that version for the
 * Library.
 */

package com.sadofftext.Symbolic;

import java.io.UnsupportedEncodingException;
import java.nio.charset.Charset;
import java.util.Locale;

/**
 * The class variable. This is used to represent a variable in a CAS.
 * As such 'x' can just be 'x' and not the typical: `int x = 2`.
 * 
 * Examples:
 * <ul>
 *  <li> 3x<sup>2</sup> &mdash; {@code new Variable(3, "x", 2);} </li>
 *  <li> 3x &mdash; {@code new Variable(3, "x");} </li>
 *  <li> x<sup>2</sup> &mdash; {@code new Variable("x", 2);} </li>
 *  <li> x &mdash; {@code new Variable("x");} </li>
 * </ul>
 * 
 * @author Eli David Sadoff
 * @since 1.0
 * @version 1.0
 *
 */
public class Variable implements Operations<Variable>{
  /** This holds the coefficient of the variable */
  private Numeric coefficient;
  /** This holds the name of the variable */
  private String name;
  /** This holds the exponent */
  private Numeric exponent;
  
  /**
   * This is the convenience constructor for the Variable.
   * This is to be used for a variable with a coefficient and exponent.
   * 
   * @param coefficient the coefficient to set
   * @param name the name to set 
   * @param exponent the exponent to set
   */
  public Variable(Numeric coefficient, String name, Numeric exponent){
    this.coefficient  = coefficient;
    this.name = name;
    this.exponent = exponent;
  }
  
  /**
   * This is the convenience constructor for the Variable.
   * This is to be used for a variable with a coefficient and exponent.
   * 
   * @param coefficient the coefficient to set
   * @param name the name to set 
   * @param exponent the exponent to set
   */
  public Variable(int coefficient, String name, int exponent){
    this.coefficient  = new IntegerType(coefficient);
    this.name = name;
    this.exponent = new IntegerType(exponent);
  }
  
  /**
   * This is a constructor for a variable with a coefficient but no exponent.
   * 
   * @param coefficient the coefficient to set
   * @param name the name to set 
   */
  public Variable(Numeric coefficient, String name){
    this.coefficient = coefficient;
    this.name = name;
    this.exponent = Numeric.ONE;
  }
  
  /**
   * This is a constructor for a variable with a coefficient but no exponent.
   * 
   * @param coefficient the coefficient to set
   * @param name the name to set 
   */
  public Variable(int coefficient, String name){
    this.coefficient = new IntegerType(coefficient);
    this.name = name;
    this.exponent = Numeric.ONE;
  }
  
  /**
   * This is a constructor for a variable with an exponent but no coefficient
   * 
   * @param name the name to set
   * @param exponent the exponent to set
   */
  public Variable(String name, Numeric exponent){
    this.coefficient = Numeric.ONE;
    this.name = name;
    this.exponent = exponent;
  }
  
  /**
   * This is a constructor for a variable with an exponent but no coefficient
   * 
   * @param name the name to set
   * @param exponent the exponent to set
   */
  public Variable(String name, int exponent){
    this.coefficient = Numeric.ONE;
    this.name = name;
    this.exponent = new IntegerType(exponent);
  }
  
  /**
   * This is the constructor for a variable with no exponent or coefficient.
   * 
   * @param name the name to set
   */
  public Variable(String name){
    this.coefficient = Numeric.ONE;
    this.name = name;
    this.exponent = Numeric.ONE;
  }
  
  /**
   * Gets {@code coefficient}.
   * @return the coefficient
   */
  public Numeric getCoefficient() {
    return coefficient;
  }

  /**
   * Sets {@code coefficient}.
   * @param coefficient the coefficient to set
   */
  public void setCoefficient(Numeric coefficient) {
    this.coefficient = coefficient;
  }

  /**
   * Gets {@code name}.
   * @return the name
   */
  public String getName() {
    return name;
  }

  /**
   * Sets {@code name}.
   * @param name the name to set
   */
  public void setName(String name) {
    this.name = name;
  }

  /**
   * Gets {@code exponent}.
   * @return the exponent
   */
  public Numeric getExponent() {
    return exponent;
  }

  /**
   * Sets {@code exponent}.
   * @param exponent the exponent to set
   */
  public void setExponent(Numeric exponent) {
    this.exponent = exponent;
  }

  /**
   * This method gets the <code>TeX</code> formatting of a variable.
   * @return a TeX formatted variable
   */
  public String getTeX(){
    if(getExponent().equals(1) && getCoefficient().equals(1)){
      return getName();
    } else if(getExponent().equals(1)){
      return getCoefficient().toString() + getName();
    } else if(getCoefficient().equals(1)){
      return getName() + "^{" + getExponent().toString() + "}";
    } else{
      return getCoefficient() + getName() + "^{" + getExponent().toString() + "}";
    }
  }
  
  /** 
   * @param o added
   * @return sum
   * @see com.sadofftext.Symbolic.Operations#add(java.lang.Object)
   */
  @Override
  public Variable add(Variable o) {
    // TODO Auto-generated method stub
    return null;
  }

  /** 
   * @param o subtractor
   * @return difference
   * @see com.sadofftext.Symbolic.Operations#subtract(java.lang.Object)
   */
  @Override
  public Variable subtract(Variable o) {
    // TODO Auto-generated method stub
    return null;
  }

  /** 
   * @param o multiplicand 
   * @return product
   * @see com.sadofftext.Symbolic.Operations#multiply(java.lang.Object)
   */
  @Override
  public Variable multiply(Variable o) {
    // TODO Auto-generated method stub
    return null;
  }

  /** 
   * @param o divisor
   * @return quotient
   * @see com.sadofftext.Symbolic.Operations#divide(java.lang.Object)
   */
  @Override
  public Variable divide(Variable o) {
    // TODO Auto-generated method stub
    return null;
  }

  /** 
   * @return
   * @see java.lang.Object#hashCode()
   */
  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((coefficient == null) ? 0 : coefficient.hashCode());
    result = prime * result + ((exponent == null) ? 0 : exponent.hashCode());
    result = prime * result + ((name == null) ? 0 : getName().hashCode());
    return result;
  }

  /** 
   * @param obj
   * @return
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override
  public boolean equals(Object obj) {
    if (this == obj)
      return true;
    if (obj == null)
      return false;
    if (!(obj instanceof Variable))
      return false;
    Variable other = (Variable) obj;
    if (coefficient == null) {
      if (other.coefficient != null)
        return false;
    } else if (!coefficient.equals(other.coefficient))
      return false;
    if (exponent == null) {
      if (other.exponent != null)
        return false;
    } else if (!exponent.equals(other.exponent))
      return false;
    if (name == null) {
      if (other.name != null)
        return false;
    } else if (!getName().equals(other.name))
      return false;
    return true;
  }

  /**
   * @return
   * @see java.lang.String#length()
   */
  public int length() {
    return getName().length();
  }

  /**
   * @return
   * @see java.lang.String#isEmpty()
   */
  public boolean isEmpty() {
    return getName().isEmpty();
  }

  /**
   * @param index
   * @return
   * @see java.lang.String#charAt(int)
   */
  public char charAt(int index) {
    return getName().charAt(index);
  }

  /**
   * @param index
   * @return
   * @see java.lang.String#codePointAt(int)
   */
  public int codePointAt(int index) {
    return getName().codePointAt(index);
  }

  /**
   * @param index
   * @return
   * @see java.lang.String#codePointBefore(int)
   */
  public int codePointBefore(int index) {
    return getName().codePointBefore(index);
  }

  /**
   * @param beginIndex
   * @param endIndex
   * @return
   * @see java.lang.String#codePointCount(int, int)
   */
  public int codePointCount(int beginIndex, int endIndex) {
    return getName().codePointCount(beginIndex, endIndex);
  }

  /**
   * @param index
   * @param codePointOffset
   * @return
   * @see java.lang.String#offsetByCodePoints(int, int)
   */
  public int offsetByCodePoints(int index, int codePointOffset) {
    return getName().offsetByCodePoints(index, codePointOffset);
  }

  /**
   * @param srcBegin
   * @param srcEnd
   * @param dst
   * @param dstBegin
   * @see java.lang.String#getChars(int, int, char[], int)
   */
  public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {
    getName().getChars(srcBegin, srcEnd, dst, dstBegin);
  }

  /**
   * @param srcBegin
   * @param srcEnd
   * @param dst
   * @param dstBegin
   * @deprecated
   * @see java.lang.String#getBytes(int, int, byte[], int)
   */
  public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {
    getName().getBytes(srcBegin, srcEnd, dst, dstBegin);
  }

  /**
   * @param charsetName
   * @return
   * @throws UnsupportedEncodingException
   * @see java.lang.String#getBytes(java.lang.String)
   */
  public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {
    return getName().getBytes(charsetName);
  }

  /**
   * @param charset
   * @return
   * @see java.lang.String#getBytes(java.nio.charset.Charset)
   */
  public byte[] getBytes(Charset charset) {
    return getName().getBytes(charset);
  }

  /**
   * @return
   * @see java.lang.String#getBytes()
   */
  public byte[] getBytes() {
    return getName().getBytes();
  }

  /**
   * @param sb
   * @return
   * @see java.lang.String#contentEquals(java.lang.StringBuffer)
   */
  public boolean contentEquals(StringBuffer sb) {
    return getName().contentEquals(sb);
  }

  /**
   * @param cs
   * @return
   * @see java.lang.String#contentEquals(java.lang.CharSequence)
   */
  public boolean contentEquals(CharSequence cs) {
    return getName().contentEquals(cs);
  }

  /**
   * @param anotherString
   * @return
   * @see java.lang.String#equalsIgnoreCase(java.lang.String)
   */
  public boolean equalsIgnoreCase(String anotherString) {
    return getName().equalsIgnoreCase(anotherString);
  }

  /**
   * @param anotherString
   * @return
   * @see java.lang.String#compareTo(java.lang.String)
   */
  public int compareTo(String anotherString) {
    return getName().compareTo(anotherString);
  }

  /**
   * @param str
   * @return
   * @see java.lang.String#compareToIgnoreCase(java.lang.String)
   */
  public int compareToIgnoreCase(String str) {
    return getName().compareToIgnoreCase(str);
  }

  /**
   * @param toffset
   * @param other
   * @param ooffset
   * @param len
   * @return
   * @see java.lang.String#regionMatches(int, java.lang.String, int, int)
   */
  public boolean regionMatches(int toffset, String other, int ooffset, int len) {
    return getName().regionMatches(toffset, other, ooffset, len);
  }

  /**
   * @param ignoreCase
   * @param toffset
   * @param other
   * @param ooffset
   * @param len
   * @return
   * @see java.lang.String#regionMatches(boolean, int, java.lang.String, int, int)
   */
  public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset,
      int len) {
    return getName().regionMatches(ignoreCase, toffset, other, ooffset, len);
  }

  /**
   * @param prefix
   * @param toffset
   * @return
   * @see java.lang.String#startsWith(java.lang.String, int)
   */
  public boolean startsWith(String prefix, int toffset) {
    return getName().startsWith(prefix, toffset);
  }

  /**
   * @param prefix
   * @return
   * @see java.lang.String#startsWith(java.lang.String)
   */
  public boolean startsWith(String prefix) {
    return getName().startsWith(prefix);
  }

  /**
   * @param suffix
   * @return
   * @see java.lang.String#endsWith(java.lang.String)
   */
  public boolean endsWith(String suffix) {
    return getName().endsWith(suffix);
  }

  /**
   * @param ch
   * @return
   * @see java.lang.String#indexOf(int)
   */
  public int indexOf(int ch) {
    return getName().indexOf(ch);
  }

  /**
   * @param ch
   * @param fromIndex
   * @return
   * @see java.lang.String#indexOf(int, int)
   */
  public int indexOf(int ch, int fromIndex) {
    return getName().indexOf(ch, fromIndex);
  }

  /**
   * @param ch
   * @return
   * @see java.lang.String#lastIndexOf(int)
   */
  public int lastIndexOf(int ch) {
    return getName().lastIndexOf(ch);
  }

  /**
   * @param ch
   * @param fromIndex
   * @return
   * @see java.lang.String#lastIndexOf(int, int)
   */
  public int lastIndexOf(int ch, int fromIndex) {
    return getName().lastIndexOf(ch, fromIndex);
  }

  /**
   * @param str
   * @return
   * @see java.lang.String#indexOf(java.lang.String)
   */
  public int indexOf(String str) {
    return getName().indexOf(str);
  }

  /**
   * @param str
   * @param fromIndex
   * @return
   * @see java.lang.String#indexOf(java.lang.String, int)
   */
  public int indexOf(String str, int fromIndex) {
    return getName().indexOf(str, fromIndex);
  }

  /**
   * @param str
   * @return
   * @see java.lang.String#lastIndexOf(java.lang.String)
   */
  public int lastIndexOf(String str) {
    return getName().lastIndexOf(str);
  }

  /**
   * @param str
   * @param fromIndex
   * @return
   * @see java.lang.String#lastIndexOf(java.lang.String, int)
   */
  public int lastIndexOf(String str, int fromIndex) {
    return getName().lastIndexOf(str, fromIndex);
  }

  /**
   * @param beginIndex
   * @return
   * @see java.lang.String#substring(int)
   */
  public String substring(int beginIndex) {
    return getName().substring(beginIndex);
  }

  /**
   * @param beginIndex
   * @param endIndex
   * @return
   * @see java.lang.String#substring(int, int)
   */
  public String substring(int beginIndex, int endIndex) {
    return getName().substring(beginIndex, endIndex);
  }

  /**
   * @param beginIndex
   * @param endIndex
   * @return
   * @see java.lang.String#subSequence(int, int)
   */
  public CharSequence subSequence(int beginIndex, int endIndex) {
    return getName().subSequence(beginIndex, endIndex);
  }

  /**
   * @param str
   * @return
   * @see java.lang.String#concat(java.lang.String)
   */
  public String concat(String str) {
    return getName().concat(str);
  }

  /**
   * @param oldChar
   * @param newChar
   * @return
   * @see java.lang.String#replace(char, char)
   */
  public String replace(char oldChar, char newChar) {
    return getName().replace(oldChar, newChar);
  }

  /**
   * @param regex the regular expression to check if the string matches
   * @return if the string matches the pattern
   * @see java.lang.String#matches(java.lang.String)
   */
  public boolean matches(String regex) {
    return getName().matches(regex);
  }

  /**
   * @param s the sequence to check
   * @return if the variable name contains the sequence
   * @see java.lang.String#contains(java.lang.CharSequence)
   */
  public boolean contains(CharSequence s) {
    return getName().contains(s);
  }

  /**
   * @param regex the regular expression to replace 
   * @param replacement the replacement
   * @return a string with the first matching pattern replaced
   * @see java.lang.String#replaceFirst(java.lang.String, java.lang.String)
   */
  public String replaceFirst(String regex, String replacement) {
    return getName().replaceFirst(regex, replacement);
  }

  /**
   * @param regex the regular expression to replace
   * @param replacement the replacement
   * @return a string with all of the matching patterns replaced
   * @see java.lang.String#replaceAll(java.lang.String, java.lang.String)
   */
  public String replaceAll(String regex, String replacement) {
    return getName().replaceAll(regex, replacement);
  }

  /**
   * @param target the sequence of characters to replace
   * @param replacement the sequence of characters that the chars will be replaced with
   * @return a transformed char
   * @see java.lang.String#replace(java.lang.CharSequence, java.lang.CharSequence)
   */
  public String replace(CharSequence target, CharSequence replacement) {
    return getName().replace(target, replacement);
  }

  /**
   * @param regex the regex to split the string
   * @param limit the number of times the string is to be split
   * @return a split string
   * @see java.lang.String#split(java.lang.String, int)
   * @see #split(String)
   */
  public String[] split(String regex, int limit) {
    return getName().split(regex, limit);
  }

  /**
   * @param regex the regular expression on which to split the string
   * @return a string split by the provided regex
   * @see java.lang.String#split(java.lang.String)
   */
  public String[] split(String regex) {
    return getName().split(regex);
  }

  /**
   * @param locale the locale of the user
   * @return the string into a locale based lower case
   * @see java.lang.String#toLowerCase(java.util.Locale)
   * @see #toLowerCase()
   */
  public String toLowerCase(Locale locale) {
    return getName().toLowerCase(locale);
  }

  /**
   * Turns the variable name to lower case
   * @return the variable name in lower case
   * @see java.lang.String#toLowerCase()
   */
  public String toLowerCase() {
    return getName().toLowerCase();
  }

  /**
   * @param locale the locale of the user
   * @return turns the string into a locale based upper case
   * @see java.lang.String#toUpperCase(java.util.Locale)
   * @see #toUpperCase()
   */
  public String toUpperCase(Locale locale) {
    return getName().toUpperCase(locale);
  }

  /**
   * The variable name in all upper case
   * @return the variable name in all upper case
   * @see java.lang.String#toUpperCase()
   */
  public String toUpperCase() {
    return getName().toUpperCase();
  }

  /**
   * Returns a string whose value is this string, with any leading and trailing whitespace removed.
   * 
   * @return The variable name with leading and trailing whitespace removed
   * @see java.lang.String#trim()
   */
  public String trim() {
    return getName().trim();
  }

  /**
   * Turns name into a charArray
   * 
   * @return a char array of the string name
   * @see java.lang.String#toCharArray()
   */
  public char[] toCharArray() {
    return getName().toCharArray();
  }

  /**
   * Returns a canonical representation for the string object.
   * 
   * @return a string identical in characters to the string in Name, but from a unique pool
   * @see java.lang.String#intern()
   */
  public String intern() {
    return getName().intern();
  }
}
